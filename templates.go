package yaber

import (
	"bytes"
	"go/format"
	"text/template"
)

var (
	tmplMain *template.Template
	tmplTest *template.Template
)

func init() {
	tmplMain = template.Must(template.New("main").Parse(rawTmplMain))
	tmplTest = template.Must(template.New("test").Parse(rawTmplTest))
}

func runTemplate(tmpl *template.Template, data map[string]interface{}) ([]byte, error) {
	buf := new(bytes.Buffer)
	tmpl.Execute(buf, data)
	return format.Source(buf.Bytes())
}

var rawTmplMain = `//go:generate {{.command}}

// Code generated by yaber v{{.version}} (https://github.com/lmas/yaber)
// DO NOT EDIT.

package {{.package}}

import (
        "bytes"
        "compress/gzip"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
)

var _useRawAssets = false

// {{.setRawFunc}} toggles reading files from hard disk (b = true) or from the
// embedded files (b = false).
func {{.setRawFunc}}(b bool) {
        _useRawAssets = b
}

// {{.assetFunc}} returns the contents of a file as a []byte.
func {{.assetFunc}}(path string) ([]byte, error) {
        if _useRawAssets {
                return getRaw(path)
        }
        return getEmbedded(path)
}

// {{.assetFunc}}Dir returns a map where the keys are file paths and the values
// are the file contents.
func {{.assetFunc}}Dir(dir string) (map[string][]byte, error) {
        if _useRawAssets {
                return getRawDir(dir)
        }
        return getEmbeddedDir(dir)
}

func getRaw(path string) ([]byte, error) {
        return ioutil.ReadFile(path)
}

func getRawDir(dir string) (map[string][]byte, error) {
        list := make(map[string][]byte)
        dirs := []string{dir}

        for len(dirs) > 0 {
                d := dirs[0]
                dirs = dirs[1:]
                files, e := ioutil.ReadDir(d)
                if e != nil {
                        return nil, e
                }

                for _, f := range files {
                        fpath := filepath.Join(d, f.Name())

                        if f.IsDir() {
                                dirs = append(dirs, fpath)
                                continue
                        }
                        if !f.Mode().IsRegular() {
                                continue
                        }

                        fbody, e := ioutil.ReadFile(fpath)
                        if e != nil {
                                return nil, e
                        }
                        list[fpath] = fbody
                }
        }
        return list, nil
}

func getEmbedded(path string) ([]byte, error) {
        body, ok := _rawAssets[path]
        if !ok {
                return nil, os.ErrNotExist
        }
        return decompress(body)
}

func getEmbeddedDir(dir string) (map[string][]byte, error) {
        var e error
        files := make(map[string][]byte)
        for path, body := range _rawAssets {
                if strings.HasPrefix(path, dir) {
                        files[path], e = decompress(body)
                        if e != nil {
                                return nil, e
                        }
                }
        }
        return files, nil
}

func decompress(data []byte) ([]byte, error) {
        buf := bytes.NewBuffer(data)
        gr, e := gzip.NewReader(buf)
        if e != nil {
        	if e == io.EOF{
        		return []byte{}, nil
		}
                return nil, e
        }
        defer gr.Close()
        return ioutil.ReadAll(gr)
}

var _rawAssets = map[string][]byte{
{{range $path, $body := .files}}
	"{{$path}}": []byte({{printf "%+q" $body}}),
{{end}}
}
`

var rawTmplTest = `
// Code generated by yaber v{{.version}} (https://github.com/lmas/yaber)
// DO NOT EDIT.

package {{.package}}

import (
	"bytes"
	"os"
	"testing"
)

var oldDir string

func chDir() {
	// Must go up a dir because go test enters the dir with the currently
	// running test file.
	var e error
	oldDir, e = os.Getwd()
	if e != nil {
		panic(e)
	}
	e = os.Chdir("..")
	if e != nil {
		panic(e)
	}
}

func restoreDir() {
	e := os.Chdir(oldDir)
	if e != nil {
		panic(e)
	}
}

func testFile(t *testing.T, path string, body []byte) {
	b, e := {{.assetFunc}}(path)
	if e != nil {
		t.Errorf("Unexpected error when reading%s: %s", path, e.Error())
	}
	if len(b) != len(body) {
		t.Errorf("Unexpected length of %s, excpected=%d, got=%d", path, len(body), len(b))
	}
	if !bytes.Equal(b, body) {
		t.Errorf("File contents doesn't match for %s", path)
	}
}

func TestSingleFile(t *testing.T) {
	chDir()
	defer restoreDir()
	// First embedded file and it's compressed body.
	name := "{{.firstPath}}"
	body, e := decompress([]byte({{printf "%+q" .firstBody}}))
	if e != nil {
		t.Errorf("Unexpected error when decompressing test file body: %s", e.Error())
	}
	// Compare against embedded file.
	{{.setRawFunc}}(false)
	testFile(t, name, body)

	// Compare against real file on disk.
	{{.setRawFunc}}(true)
	testFile(t, name, body)
}

func testDir(t *testing.T, dir string, fileNames []string) {
	hasFile := func(f string) bool {
		for _, n := range fileNames {
			if n == f {
				return true
			}
		}
		return false
	}

	files, e := {{.assetFunc}}Dir(dir)
	if e != nil {
		t.Errorf("Unexpected error while reading: %s", e.Error())
	}

	if len(fileNames) != len(files) {
		t.Errorf("Unexpected file amount, expected=%d, got=%d", len(fileNames), len(files))
	}

	for f := range files {
		if !hasFile(f) {
			t.Errorf("Missing file %s in directory", f)
		}
	}
}

func TestAllFiles(t *testing.T) {
	chDir()
	defer restoreDir()
	// List of all embedded files.
	names := []string{
{{range $path, $body := .files}}
		"{{$path}}",
{{end}}
	}

	// List of all dirs.
	dirs := []string{
{{range $d := .dirs}}
		"{{$d}}",
{{end}}
	}

	{{.setRawFunc}}(false)
	for _, d := range dirs {
		testDir(t, d, names)
	}

	{{.setRawFunc}}(true)
	for _, d := range dirs {
		testDir(t, d, names)
	}
}
`
